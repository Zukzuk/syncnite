#!/usr/bin/env node
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import pkg from '../package.json' with { type: 'json' };

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT = path.resolve(__dirname, '..');
const VERSION = pkg.version;
if (!VERSION) {
    console.error('No "version" in package.json'); process.exit(1);
}

function write(filePath, content) {
    fs.mkdirSync(path.dirname(filePath), { recursive: true });
    fs.writeFileSync(filePath, content);
    console.log('✓ wrote', path.relative(ROOT, filePath));
}

// Generate C# version inside the Playnite project
(() => {
    const out = path.join(ROOT, 'playnite', 'SyncniteBridge', 'Version.g.cs');
    const content = `// <auto-generated/>
namespace SyncniteBridge
{
    internal static class BridgeVersion
    {
        public const string Current = "${VERSION}";
    }
}
`;
    write(out, content);
})();

// Render extension.yaml from template
(() => {
    const projDir = path.join(ROOT, 'playnite', 'SyncniteBridge');
    const tplPath = path.join(projDir, 'extension.yaml.tpl');
    const outYaml = path.join(projDir, 'extension.yaml');

    if (!fs.existsSync(tplPath)) {
        console.error(`Missing template: ${path.relative(ROOT, tplPath)}. Create it and include "\${VERSION}".`);
        process.exit(1);
    }
    const rendered = fs.readFileSync(tplPath, 'utf8').replace(/\$\{VERSION\}/g, VERSION);
    write(outYaml, rendered);
})();

console.log(`✅ Version sync complete (${VERSION})`);
